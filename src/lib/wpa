## /usr/lib/network/globals needs to be sourced before this file


## Discover non-standard ctrl_interface
# usage: control_dir=$(wpa_ctrl_discover)
# $1: path to wpa_supplicant config file in use
wpa_ctrl_discover() {
  local conf=$1
  [[ $conf ]] || { echo /run/wpa_supplicant; return; }
  wpa_ctrl=$(grep -m1 "ctrl_interface=" "$conf" /dev/null)
  wpa_ctrl=${wpa_ctrl##*DIR=}
  echo "${wpa_ctrl%% GROUP*}"
}

## Check if an instance of the wpa supplicant is active on an interface
# $1: interface name
wpa_is_active(){
  [[ $(wpa_call "$1" ping 2> /dev/null) == PONG ]]
}

## Retrieves the state of an instance of the wpa supplicant
## Displays one of: DISCONNECTED, INTERFACE_DISABLED, INACTIVE, SCANNING,
##                  AUTHENTICATING, ASSOCIATING, ASSOCIATED, 4WAY_HANDSHAKE,
##                  GROUP_HANDSHAKE, COMPLETED
# $1: interface name
wpa_get_state() {
  local state
  state=$(wpa_call "$1" status | grep -m1 "wpa_state=") || return
  echo "${state#*wpa_state=}"
}

## Waits until the wpa supplicant reaches a listed state
# $1: interface name
# $2...: accepted states
wpa_wait_until_state() {
  local interface=$1 states=( "${@:2}" )
  until in_array "$(wpa_get_state "$interface")" "${states[@]}"; do
    sleep 2
  done
}

## Waits while the wpa supplicant is in a listed state
# $1: interface name
# $2...: rejected states
wpa_wait_while_state() {
  local interface=$1 states=( "${@:2}" )
  while in_array "$(wpa_get_state "$interface")" "${states[@]}"; do
    sleep 2
  done
}

## Actions

## Wrapper around wpa_cli to deal with supplicant configurations that set a
## non-standard control path
# $1: interface name
# $2...: call to the supplicant
wpa_call() {
  do_debug wpa_cli -i "$1" -p "$wpa_ctrl_dir" "${@:2}"
}

## Start an instance of the wpa supplicant
# $1: interface name
# $2: interface driver(s)
# $3: configuration file
wpa_start() {
  local interface=$1 driver=$2 conf=$3
  local pidfile=/run/wpa_supplicant_$interface.pid
  local -a wpa_supp_opts=( -B
                          -P "$pidfile"
                          -i "$interface"
                          -D "$driver"
                          )

  [[ $conf ]] && wpa_supp_opts+=(-c "$conf"
                                -C "$(wpa_ctrl_discover "$conf")"
                                )

  ## TODO: figure out where $WPAOptions comes from, fix it.
  # netctl-auto ???
  do_debug wpa_supplicant "${wpa_supp_opts[@]}" $WPAOptions

  ## TODO: do we not just blindly clobber this file anyway?
  # at worst, this should be in a failure state cleanup process
  # save this for user inspection and debugging
  # Wait at least one second for the pid file to appear
  # sleep
  # if [[ ! -f $pidfile ]]; then
  #   # Remove the confuration file if it was generated
  #   [[ -f $conf && -O $conf ]] && rm -f "$conf"
  #   return 1
  # fi
}

## Stop an instance of the wpa supplicant
# $1: interface name
# $2: config file
# $3: wpa_supplicant control interface
wpa_stop() {
  local interface=$1 conf=$2 wpa_ctrl=${3:-/run/wpa_supplicant}

  # Done if wpa_supplicant is already terminated for this interface
  [[ -e $wpa_ctrl/$interface ]] || return

  wpa_call "$interface" terminate > /dev/null
  ## TODO: still want to save this maybe
  # [[ -f $conf && -O $conf ]] && rm -f "$conf"

  # Wait at least one second for the pid file to be removed
  # sleep
  # if [[ ! -f /run/wpa_supplicant_$interface.pid ]]; then
  #   kill "$(< "/run/wpa_supplicant_$interface.pid")" &> /dev/null
  # fi
}

## Scan for networks within range
# $1: interface name
# $2: fields of the wpa_supplicant scan_results
wpa_supplicant_scan() {
  ## TODO: still needs generic work
  local interface=$1 fields=$2 spawned_wpa=0 essids

  [[ $interface ]] || return 1

  if ! wpa_is_active "$interface"; then
    wpa_start "$interface" "${WPADriver:-nl80211,wext}" || return
    spawned_wpa=1
  fi

  wpa_call "$interface" scan > /dev/null
  # Wait at least 3 seconds for scan results
  sleep 3
  # Sometimes, that is not enough
  wpa_wait_while_state 7 "$interface" "SCANNING"
  {
    IFS= read; while IFS= read -r _ _ _ _ essid; do
      ssids+=("$essid")
    done
  } < <(wpa_call "$interface" scan_results)

  (( spawned_wpa == 1 )) && wpa_stop "$interface"

  echo "$essids"
}

## Print a string within quotes, unless it starts with the "-modifier
## Quoted:     string   "string"   '""string"'
## Non-quoted: \"string "\"string" '"string'
# $1: string
wpa_quote() {
  local string=$1
  if [[ $string == \"* ]]; then
    printf '%s' "${string:1}"
  else
    printf '"%s"' "$string"
  fi
}

## Create a configuration file for wpa_supplicant without any network blocks
# $1: interface name
wpa_make_config_file() {
  local config_file="$state_dir/wpa_supplicant_$1.conf"

  if [[ -e $config_file ]]; then
    report debug "The anticipated filename '$config_file' is not available"
    return 1
  fi
  mkdir -p "$state_dir" /run/wpa_supplicant
  if ! : > "$config_file"; then
    report debug "Could not create the configuration file '$config_file'"
    return 1
  fi
  chmod 600 "$config_file"

  echo "ctrl_interface=/run/wpa_supplicant" >> "$config_file"
  echo "ctrl_interface_group=${WPAGroup:-wheel}" >> "$config_file"
  [[ $Country ]] && echo "country=$Country" >> "$config_file"
  if is_yes "${AdHoc:-no}"; then
    echo "ap_scan=2" >> "$config_file"
  fi
  echo "$config_file"
}

## Generate a network block for wpa_supplicant
# $1: type of wireless security
wpa_make_config_block() {
  local security=$1
  case $security in
    none)
      echo "key_mgmt=NONE"
      ;;
    wep)
      echo "key_mgmt=NONE"
      echo "wep_tx_keyidx=0"
      echo "wep_key0=$(wpa_quote "$Key")"
      ;;
    wpa)
      echo "proto=RSN WPA"
      if [[ "${#Key}" -eq 64 ]]; then
        echo "psk=$Key"
      else
        echo "psk=$(wpa_quote "$Key")"
      fi
      ;;
    wpa-configsection)
      printf "%s\n" "${WPAConfigSection[@]}"
      return
      ;;
    *)
      report error "Unsupported security setting: $Security"
      return 1
      ;;
  esac

  echo "ssid=$(wpa_quote "$ESSID")"
  [[ $AP ]] && echo "bssid=${AP,,}"
  is_yes "${Hidden:-no}" && echo "scan_ssid=1"
  is_yes "${AdHoc:-no}" && echo "mode=1"
  [[ $Priority ]] && echo "priority=$Priority"
}


# vim: ft=sh ts=2 et sw=2:
