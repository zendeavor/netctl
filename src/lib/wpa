## /usr/lib/network/globals needs to be sourced before this file


## TODO: could just use this globally instead of capturing?
## but i don't think we need this at all
# wpa_ctrl_discover() {
#   local conf=$1
#   [[ $conf ]] || { echo /run/wpa_supplicant; return; }
#   wpa_ctrl=$(grep -m1 "ctrl_interface=" "$conf" /dev/null)
#   wpa_ctrl=${wpa_ctrl##*DIR=}
#   echo "${wpa_ctrl%% GROUP*}"
# }

wpa_is_active(){
  local iface=$1
  [[ $(wpa_call "$iface" ping 2> /dev/null) == PONG ]]
}

## Displays one of: DISCONNECTED, INTERFACE_DISABLED, INACTIVE, SCANNING,
##                  AUTHENTICATING, ASSOCIATING, ASSOCIATED, 4WAY_HANDSHAKE,
##                  GROUP_HANDSHAKE, COMPLETED
## TODO: could just use this globally instead of capturing?
wpa_get_state() {
  local iface=$1 state
  state=$(wpa_call "$iface" status | grep -m1 "wpa_state=") || return
  echo "${state#*wpa_state=}"
}

wpa_wait_until_state() {
  local iface=$1 states=( "${@:2}" )
  until in_array "$(wpa_get_state "$iface")" "${states[@]}"; do
    sleep 2
  done
}

wpa_wait_while_state() {
  local iface=$1 states=( "${@:2}" )
  while in_array "$(wpa_get_state "$iface")" "${states[@]}"; do
    sleep 2
  done
}

## Actions

wpa_call() {
  local iface=$1 wpactl=$2
  wpa_cli -i "$iface" -p "$wpactl" "${@:3}"
} 2>/dev/null

wpa_start() {
  local interface=$1 driver=$2 conf=$3
  local pidfile=/run/wpa_supplicant_$interface.pid
  local -a wpa_supp_opts=(-B
                          -P "$pidfile"
                          -i "$interface"
                          -D "$driver"
                          -c <(wpa_make_config)
                          )

  ## TODO: figure out where $WPAOptions comes from, fix it.
  # netctl-auto ???
  wpa_supplicant "${wpa_supp_opts[@]}" $WPAOptions

}

wpa_stop() {
  local interface=$1 wpactl=$2
  wpa_call "$interface" terminate
}

wpa_supplicant_scan() {
  ## TODO: still needs generic work
  local interface=$1 fields=$2 driver=${3:-nl80211,wext} spawned_wpa=0 essid

  wpa_call "$interface" scan > /dev/null
  sleep 3
  wpa_wait_while_state "$interface" "SCANNING"
  {
    IFS= read; while IFS= read -r _ _ sig _ essid; do
      ((sig > oldsig))
      ssids+=("$essid")
    done
  } < <(wpa_call "$interface" scan_results)

  printf '%s\n' "${ssids[@]}"
} 2>/dev/null

## TODO: maybe wpa_supplicant -c <(wifi_make_config)
wifi_make_config() {
  local -A wificonf=()
  wificonf=(
            [ctrl_interface]=$ctliface
            [ctrl_interface_group]=$ctlgroup

            [priority]=$precedence
            [scan_ssid]=$hidden
            [mode]=$mode
            [ap_scan]=$adhoc
            [country]=$country

            [ssid]=$essid
            [bssid]=$bssid

            [key_mgmt]=$keymgmt
            [proto]=$proto

            [pairwise]=$wpapairwise
            [group]=$wpagroup
            [psk]=$wpakey

            [eap]=$wpaeap
            [phase2]=$phase2auth
            [identity]=$ieeeuser
            [password]=$ieeepass
            [ca_cert]=$cert
            [private_key]=$certkey
            [private_key_passwd]=$certpass

            [engine]=$pkcs
            [engine_id]=$pkcs11
            [key_id]=$pkcskey
            [cert_id]=$pkcscert
            [ca_cert_id]=$pkcscertid
            [pin]=$pkcspin

            [wep_tx_keyidx]=$wepkeyidx
            [wep_key$wepkeyidx]=$wepkey
          )
}


# vim: ft=sh ts=2 et sw=2:
