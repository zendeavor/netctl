## /usr/lib/network/globals needs to be sourced before this file


## Discover non-standard ctrl_interface
## TODO: could just use this globally instead of capturing?
## but i don't think we need this at all
# usage: control_dir=$(wpa_ctrl_discover)
# $1: path to wpa_supplicant config file in use
wpa_ctrl_discover() {
  local conf=$1
  [[ $conf ]] || { echo /run/wpa_supplicant; return; }
  wpa_ctrl=$(grep -m1 "ctrl_interface=" "$conf" /dev/null)
  wpa_ctrl=${wpa_ctrl##*DIR=}
  echo "${wpa_ctrl%% GROUP*}"
}

## Check if an instance of the wpa supplicant is active on an interface
# $1: interface name
wpa_is_active(){
  local iface=$1
  [[ $(wpa_call "$iface" ping 2> /dev/null) == PONG ]]
}

## Retrieves the state of an instance of the wpa supplicant
## Displays one of: DISCONNECTED, INTERFACE_DISABLED, INACTIVE, SCANNING,
##                  AUTHENTICATING, ASSOCIATING, ASSOCIATED, 4WAY_HANDSHAKE,
##                  GROUP_HANDSHAKE, COMPLETED
## TODO: could just use this globally instead of capturing?
# $1: interface name
wpa_get_state() {
  local iface=$1 state
  state=$(wpa_call "$iface" status | grep -m1 "wpa_state=") || return
  echo "${state#*wpa_state=}"
}

## Waits until the wpa supplicant reaches a listed state
# $1: interface name
# $2...: accepted states
wpa_wait_until_state() {
  local iface=$1 states=( "${@:2}" )
  until in_array "$(wpa_get_state "$iface")" "${states[@]}"; do
    sleep 2
  done
}

## Waits while the wpa supplicant is in a listed state
# $1: interface name
# $2...: rejected states
wpa_wait_while_state() {
  local iface=$1 states=( "${@:2}" )
  while in_array "$(wpa_get_state "$iface")" "${states[@]}"; do
    sleep 2
  done
}

## Actions

## Wrapper around wpa_cli to deal with supplicant configurations that set a
## non-standard control path
# $1: interface name
# $2...: call to the supplicant
wpa_call() {
  local iface=$1 wpactl=$2
  wpa_cli -i "$iface" -p "$wpactl" "${@:3}"
} 2>/dev/null

## Start an instance of the wpa supplicant
# $1: interface name
# $2: interface driver(s)
# $3: configuration file
wpa_start() {
  local interface=$1 driver=$2 conf=$3
  local pidfile=/run/wpa_supplicant_$interface.pid
  local -a wpa_supp_opts=(-B
                          -P "$pidfile"
                          -i "$interface"
                          -D "$driver"
                          -c <(wpa_make_config)
                          )

  ## TODO: figure out where $WPAOptions comes from, fix it.
  # netctl-auto ???
  wpa_supplicant "${wpa_supp_opts[@]}" $WPAOptions

}

## Stop an instance of the wpa supplicant
# $1: interface name
# $2: config file
# $3: wpa_supplicant control interface
wpa_stop() {
  local interface=$1 wpactl=$2
  wpa_call "$interface" terminate
}

## Scan for networks within range
# $1: interface name
# $2: fields of the wpa_supplicant scan_results
wpa_supplicant_scan() {
  ## TODO: still needs generic work
  local interface=$1 fields=$2 driver=${3:-nl80211,wext} spawned_wpa=0 essid

  wpa_call "$interface" scan > /dev/null
  # Wait at least 3 seconds for scan results
  sleep 3
  # Sometimes, that is not enough
  wpa_wait_while_state "$interface" "SCANNING"
  {
    IFS= read; while IFS= read -r _ _ _ _ essid; do
      ssids+=("$essid")
    done
  } < <(wpa_call "$interface" scan_results)

  printf '%s\n' "${ssids[@]}"
} 2>/dev/null

## Print a string within quotes, unless it starts with the "-modifier
## Quoted:     string   "string"   '""string"'
## Non-quoted: \"string "\"string" '"string'
# $1: string
# wpa_quote() {
#   local string=$1
#   if [[ $string == \"* ]]; then
#     printf '%s' "${string:1}"
#   else
#     printf '"%s"' "$string"
#   fi
# }


## Generate a config for wpa_supplicant
## TODO: wpa_supplicant -c <(wifi_make_config)
# $1: type of wireless security
wifi_make_config() {
  local -A wpaconf=()
  case $security in
    none)
      keymgmt=key_mgmt=NONE
      ;;
    wep)
      echo "key_mgmt=NONE"
      echo "wep_tx_keyidx=0"
      echo "wep_key0=$Key"
      ;;
    wpa)
      echo "proto=RSN WPA"
      if (( ${#Key} == 64 )); then
        echo "psk=$Key"
      else
        echo "psk=$Key"
      fi
      ;;
    wpa-configsection)
      printf "%s\n" "${WPAConfigSection[@]}"
      return
      ;;
    *)
      report error "Unsupported security setting: $security"
      return 1
      ;;
  esac
  wpaconf=(
            [ctrl_interface]=$ctliface
            [ctrl_interface_group]=$ctlgroup

            [priority]=$precedence

            [country]=$country

            [ssid]=$essid
            [bssid]=$bssid

            [key_mgmt]=$keymgmt
            [proto]=$proto

            [pairwise]=$wpapairwise
            [group]=$wpagroup
            [psk]=$wpakey

            [eap]=$wpaeap
            [phase2]=$phase2auth
            [identity]=$ieeeuser
            [password]=$ieeepass
            [ca_cert]=$cert
            [private_key]=$certkey
            [private_key_passwd]=$certpass

            [engine]=$pkcs
            [engine_id]=$pkcs11
            [key_id]=$pkcskey
            [cert_id]=$pkcscert
            [ca_cert_id]=$pkcscertid
            [pin]=$pkcspin

            [wpa_tx_keyidx]=$wepkeyidx
            [wpa_key$wepkeyidx]=$wepkey

            [scan_ssid]=$hidden
            [mode]=$mode
            [ap_scan]=$adhoc
          )
}


# vim: ft=sh ts=2 et sw=2:
