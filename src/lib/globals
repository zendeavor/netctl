netctl_version=notpackaged
profile_dir=/etc/netctl

subr_dir=/usr/lib/network
conn_dir=$subr_dir/connections
state_dir=/run/network
state_file=${netctl_state_file:-/var/lib/netctl/netctl.state}


### Logging/Error reporting

report() {
    type="$1"; shift
    case "$type" in
        debug)
            is_yes "${netctl_debug:-no}" || return
            set -- DEBUG: "$@"
            ;;
        notice)
            set -- NOTICE: "$@"
            ;;
        error)
            set -- ERROR: "$@"
            ;;
        *)
            ;;
    esac
}

### Variable management

## Check if a variable occurs in an array
# $1: the variable to find
# $2...: the array elements
in_array() {
    local hay needle=$1
    shift
    for hay; do
        [[ $hay == $needle ]] && return 0
    done
    return 1
}

## Check if a variable denotes a positive truth value
# $1: the variable to check, use is_yes ${VAR:-yes} to set a default
is_yes() {
    case "${1,,}" in
        yes|true|on|1)
            return 0
            ;;
        no|false|off|0)
            return 1
            ;;
        *)
            report error "Not a valid truth value: $1"
            return 2
            ;;
    esac
}


### Control flow

## Show what we evaluate when debugging, but always evaluate
do_debug() {
    report debug "${FUNCNAME[1]}:" "$@"
    "$@"
}

## Exit if we are not effectively root
# $1: program name (optional)
ensure_root() {
    (( EUID == 0 )) || report error "${1-$0} needs root privileges"
}

### TODO: Rework timeout_wait()
## Waits until a statement succeeds or a timeout occurs
# $1: timeout in seconds
# $2...: condition command
timeout_wait() {
    local timeout=$1
    (( timeout *= 5 ))
    shift
    until "$@"; do
        (( timeout-- > 0 )) || return 1
        sleep 0.2
    done
}


### Profile management

## List all acceptable profiles names (assume they don't contain newlines)
list_files() {
    # JP: follow aliases with -L, also skip profiles that end with '.conf' (so
    #     profile.conf can be the wpa.conf file for profile)
    dir=${1-.}
    find -L "$dir/" -maxdepth 1 -type f \
        ! -name '.*' ! -name '*~' ! -name '*.conf' \
        ! -name '*.service' -printf "%f\n"
}

## Sources all hooks, a profile and any interface hook
# $1: profile name
load_profile() {
    local hook
    if [[ ! -r $profile_dir/$1 ]]; then
        report error "Profile $1 does not exist or is not readable"
    fi
    while read -r hook; do
        source "$hook"
    done < <(list_files "$profile_dir/hooks" | sort -u)
    source "$profile_dir/$1"
    if [[ -z $Interface ]]; then
        report error "Profile $1 does not specify an interface"
    fi
    if [[ ! -r ${Connection:+$conn_dir/$connection} ]]; then
        report error "Profile $1 does not specify a valid connection"
    fi
    if [[ -x $profile_dir/interfaces/$interface ]]; then
        source "$profile_dir/interfaces/$interface"
    fi
    source "$conn_dir/$connection"
}


### DHCP Client selection

## Check validity of DHCP Client defined by user
which_dhcp() {
    "${DHCPClient[@]}" &>/dev/null || \
        report error "DHCP Client $DHCPClient[@] not found."
}


# vim: ft=sh ts=4 et sw=4:
